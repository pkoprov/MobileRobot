# fit_ff_from_csv.py
import csv, math, argparse
from statistics import mean

def linreg(x, y):
    # simple least squares, returns (a, b, r2) for y = a*x + b
    n = len(x)
    if n < 2: return (0.0, 0.0, 0.0)
    mx, my = mean(x), mean(y)
    sxy = sum((xi-mx)*(yi-my) for xi,yi in zip(x,y))
    sxx = sum((xi-mx)*(xi-mx) for xi in x)
    if sxx == 0: return (0.0, my, 0.0)
    a = sxy / sxx
    b = my - a*mx
    ss_tot = sum((yi-my)**2 for yi in y)
    ss_res = sum((yi-(a*xi+b))**2 for xi,yi in zip(x,y))
    r2 = 1.0 - (ss_res/ss_tot if ss_tot>0 else 0.0)
    return (a, b, r2)

def load_rows(path):
    rows=[]
    with open(path,newline="") as f:
        r=csv.DictReader(f)
        for row in r:
            side=row["side"].strip()
            pwm=int(row["pwm"])
            tpf=float(row["ticks_per_frame"])
            rows.append({"side":side,"pwm":pwm,"tpf":tpf})
    return rows

def fit_one(rows, side, sign, tpf_min=1.0, sat_frac=0.9):
    # select direction and side
    rs=[r for r in rows if r["side"]==side and (r["pwm"]>0 if sign>0 else r["pwm"]<0)]
    if not rs: return None
    # keep midrange (avoid tiny + saturation)
    # threshold by |tpf| and cap at sat_frac of max |tpf|
    max_abs_tpf = max(abs(r["tpf"]) for r in rs) or 1.0
    tpf_max = sat_frac * max_abs_tpf
    pts=[r for r in rs if tpf_min <= abs(r["tpf"]) <= tpf_max]
    if len(pts) < 4: pts = rs  # fallback to all if filtering too aggressive
    # Fit PWM vs |tpf| with positive values
    X=[abs(r["tpf"]) for r in pts]
    Y=[abs(r["pwm"]) for r in pts]
    a,b,r2 = linreg(X,Y)
    return {"a":a,"b":b,"r2":r2, "n":len(pts), "tpf_max":max_abs_tpf}

def main():
    ap=argparse.ArgumentParser()
    ap.add_argument("--csv", default="pwm_sweep.csv")
    ap.add_argument("--tpf_min", type=float, default=1.0)
    ap.add_argument("--sat_frac", type=float, default=0.9)
    args=ap.parse_args()

    rows=load_rows(args.csv)

    fits = {
        ("L","+"): fit_one(rows,"L",+1,args.tpf_min,args.sat_frac),
        ("L","-"): fit_one(rows,"L",-1,args.tpf_min,args.sat_frac),
        ("R","+"): fit_one(rows,"R",+1,args.tpf_min,args.sat_frac),
        ("R","-"): fit_one(rows,"R",-1,args.tpf_min,args.sat_frac),
    }

    print("\n=== Linear feed-forward fits: PWM ≈ a*|tpf| + b ===")
    for k,v in fits.items():
        side,sgn=k
        if v is None:
            print(f"{side} {sgn}: no data")
            continue
        print(f"{side} {sgn}: a={v['a']:.4f}, b={v['b']:.2f}, R²={v['r2']:.4f}, n={v['n']}, |tpf|max≈{v['tpf_max']:.1f}")

    # emit header
    def cv(v): return "0.0" if v is None else f"{v:.6f}"
    def cb(v): return "0.0" if v is None else f"{v:.3f}"
    def get(key, field): 
        v=fits[key]
        return 0.0 if (v is None) else v[field]

    hdr = f"""#pragma once
// Auto-generated by fit_ff_from_csv.py
// PWM = a*|ticks_per_frame| + b (per side & direction), use sign(target) to apply direction.

struct FFParams {{
  float a_pos; // +direction slope (PWM per tick/frame)
  float b_pos; // +direction intercept/deadband (PWM)
  float a_neg; // -direction slope
  float b_neg; // -direction intercept
}};

static constexpr FFParams FF_LEFT  = {{
  {cv(get(('L','+'),'a'))}f, {cb(get(('L','+'),'b'))}f,
  {cv(get(('L','-'),'a'))}f, {cb(get(('L','-'),'b'))}f
}};

static constexpr FFParams FF_RIGHT = {{
  {cv(get(('R','+'),'a'))}f, {cb(get(('R','+'),'b'))}f,
  {cv(get(('R','-'),'a'))}f, {cb(get(('R','-'),'b'))}f
}};
"""
    with open("ff_params.h","w") as f:
        f.write(hdr)
    print("\nWrote ff_params.h with constants FF_LEFT and FF_RIGHT.")

if __name__=="__main__":
    main()
